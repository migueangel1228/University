\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc} % Para caracteres en español
\usepackage{amsmath, amssymb} % Paquetes matemáticos
\usepackage{graphicx} % Para incluir imágenes
\usepackage{hyperref} % Para enlaces internos y externos
\usepackage{geometry} % Para ajustar los márgenes
\usepackage{listings} % Para mostrar código fuente
\usepackage{xcolor} % Para colores en el código
\geometry{left=2.5cm, right=2.5cm, top=3cm, bottom=3cm}

\title{\textbf{Proyecto Final:  ``The Pursuit of Happyness: South Park-AGRA Version"}}
\author{Miguel Angel Padilla Rosero}
\date{22 de abril de 2025}

\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{lightgray!20}
}

\begin{document}

\maketitle


\section {Descripción general del problema}
El problema plantea un imperio con varias ciudades conectadas unidireccionalmente por boletos de bus que cuestan \(k\) dólares cada uno. Fuiste a la capital para comprarle un regalo a tu sobrina (una muñeca), pero tras comprar la muñeca te quedas con un presupuesto limitado. Por eso, en cada ciudad puedes quedarte un día a trabajar y ganar \(x_u\) dólares. El reto es encontrar la ruta, y si la hay, repartir los días de trabajo entre las ciudades de forma que, con el menor número de días de trabajo posible, reúnas el dinero necesario para pagar todos los boletos hasta llegar a la ciudad menos vigilada.\newline

\section {Especificación del problema}
\subsection*{Entrada}
\begin{itemize}
  \item \(N\) \((2 \le n \le 800)\): número de ciudades.
  \item \(M\) \((1 \le m \le 10\,000)\): número de rutas de autobús.
  \item \(P\) \((0 \le p \le 10^9)\): dinero ahorrado originalmente.
  \item \(R\) \((R < P)\): costo de la muñeca para Karen.
  \item \(N\) positivos enteros \(x_1, x_2, \ldots, x_N\) \((1 \le x_u \le 10^6)\): ganancia por día en ciudad \(u\).
  \item Dos enteros \(s, e\) \((1 \le s,e \le n)\): ciudad capital y ciudad menos vigilada.
  \item \(m\) líneas, cada una con tres enteros \(u, v, c\) \((1 \le u,v \le n,\ 1 \le c \le 10^6)\): ruta de \(u\) a \(v\) con costo \(c\).
\end{itemize}

\subsection*{Salida}
Imprimir exactamente una de estas dos posibles líneas:
\begin{itemize}
  \item \texttt{``Kenny happiness will cost d days of work :)''}  
    donde \(d\) es el mínimo número de días de trabajo necesarios.
  \item \texttt{``Sorry Kenny, Happiness is not for you :(''}  
    si no existe un camino de \(s\) a \(e\).
\end{itemize}

\section*{3. Definición de casos de prueba inventados}
\begin{enumerate}
  \item \textbf{Ruta directa sin trabajo}\\
    \textbf{Entrada:}
    \[
      \begin{aligned}
        &n=3,\ m=2,\ p=10,\ r=5,\\
        &x = [3,\,4,\,2],\\
        &s=1,\ e=3,\\
        &(1\to2,c=3),\ (2\to3,c=2).
      \end{aligned}
    \]
    \textbf{Explicación:} \(p-r=5\). La ruta 1→2 (costo 3) y 2→3 (costo 2) suma 5, así que no hace falta trabajar.  
    \textbf{Salida esperada:}  
    \texttt{Kenny happiness will cost 0 days of work :)}
  
  \item \textbf{No hay ruta posible}\\
    \textbf{Entrada:}
    \[
      \begin{aligned}
        &n=4,\ m=2,\ p=20,\ r=5,\\
        &x = [5,\,1,\,1,\,1],\\
        &s=1,\ e=4,\\
        &(1\to2,c=10),\ (3\to4,c=5).
      \end{aligned}
    \]
    \textbf{Explicación:} No existe conexión de 1 a 4.  
    \textbf{Salida esperada:}  
    \texttt{Sorry Kenny, Happiness is not for you :(}
  
  \item \textbf{Trabajo en ciudades intermedias}\\
    \textbf{Entrada:}
    \[
      \begin{aligned}
        &n=4,\ m=3,\ p=5,\ r=2,\\
        &x = [1,\,3,\,2,\,4],\\
        &s=1,\ e=4,\\
        &(1\to2,c=4),\ (2\to3,c=5),\ (3\to4,c=3).
      \end{aligned}
    \]
    \textbf{Explicación:} \(p-r=3\).  
    \begin{itemize}
      \item Salto 1→2 (costo 4): faltan 1\$, así que trabaja 1 día en 1 (\(+1\)\$/día).  
      \item Queda 4\$, paga → queda 0\$.  
      \item En 2 (\(+3\)\$/día) necesita 5\$: trabaja 2 días (\(+6\)\$), paga → queda 1\$.  
      \item En 3 (\(+2\)\$/día) necesita 3\$: trabaja 1 día, paga → queda 0\$.  
    \end{itemize}
    \(\Rightarrow\) Total días = \(1+2+1 = 4\).  
    \textbf{Salida esperada:}  
    \texttt{Kenny happiness will cost 4 days of work :)}
\end{enumerate}

\section {Bitácora de avances}

\subsection*{Versión 1: Modelo de grafo de estados “puro”}
\begin{itemize}
  \item \textbf{Estado}: $(\mathrm{ciudad},\ d,\ M)$ donde
    \begin{itemize}
      \item \textit{ciudad}: número de la ciudad actual.
      \item $d$: días trabajados hasta ese punto.
      \item $M$: dinero disponible en ese momento.
    \end{itemize}
  \item \textbf{Transiciones}: aún sin definir con claridad.
  \item \textbf{Problemas detectados}: 
    \begin{itemize}
      \item Espacio de estados muy grande.
      \item Dificultad para decidir cuándo generar estados de “trabajo” vs. “viaje”.
    \end{itemize}
  \item \textbf{Siguiente paso}: replantear las transiciones para reducir la complejidad.
\end{itemize}

\subsection*{Versión 2: Estados y aristas con tupla binaria}
\begin{itemize}
  \item \textbf{Estado}:
    \[
      (\mathrm{ciudad},\,(d, M))
    \]
  \item \textbf{Aristas}: cada conexión representada como $(\Delta_d,\Delta_M)$ donde
    \begin{itemize}
      \item $\Delta_d\in\{0,1\}$ indica si se trabaja un día (1) o no (0).
      \item $\Delta_M$ es cambio en dinero: $+x_u$ al trabajar, o $-\text{costo}_{u\to v}$ al viajar.
    \end{itemize}
  \item \textbf{Transiciones}:
    \begin{itemize}
      \item \emph{Trabajar en la misma ciudad}:
        \[
          (c,\,(d, M)) \xrightarrow{(1,+x_c)} (c,\,(d+1, M + x_c))
        \]
      \item \emph{Viajar a ciudad vecina} (si $M \ge \text{costo}_{u\to v}$):
        \[
          (u,\,(d, M)) \xrightarrow{(0,-\text{costo}_{u\to v})} (v,\,(d, M - \text{costo}_{u\to v}))
        \]
    \end{itemize}
  \item \textbf{Ventajas}: clarificación entre trabajar (añade días y dinero) y viajar (quita dinero).
  \item \textbf{Estado inicial}: 
    \[
      (s,\,(0,\,p - r))
    \]
    partiendo con 0 días trabajados y $M_0 = p - r$.
  \item \textbf{Estado final buscado}: 
    \[
      (e,\,(d_{\min},\,M'))
    \]
    donde $d_{\min}$ es el mínimo de días necesarios para alcanzar la ciudad menos vigilada.
  \item \textbf{Algoritmo a utilizar}: Variante de Dijkstra modificada donde
    \begin{itemize}
      \item La "distancia" a minimizar es el número de días trabajados $d$.
      \item Cada estado $(u,d)$ lleva asociado el mejor dinero $M$ visto hasta entonces.
      \item Se usa una cola de prioridad ordenada por $(d; -M)$ para extraer siempre el estado con
            menor $d$ y, en caso de empate, mayor $M$.
      \item Priorizar el mayor $M$ en empates permite conservar estados con más recursos, aumentando
            la flexibilidad para futuros viajes.
      \item Al relajar aristas de trabajo $(1,+x_u)$ o viaje $(0,-c)$, sólo se encola un nuevo estado
            si mejora el dinero disponible para esa pareja $(u,d')$.
    \end{itemize}
\end{itemize}


\section{Análisis de complejidad}
El espacio de estados está limitado a $10^4$ posibles números (desde ``0000'' hasta ``9999''). Cada estado tiene 8 posibles movimientos (dos por cada dígito). Esto implica que, en el peor de los casos, el algoritmo recorrerá hasta 10,000 estados, con una complejidad de tiempo y espacio de $O(10^4)$, lo cual es adecuado para el problema.

\section{Código Fuente}
A continuación se presenta el código implementado en C++.


\end{document}
